<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>PerlinNoiseThreeJS</title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            width: 100%;
            height: 100%;
        }

        html {
            overflow: hidden;
        }
    </style>
</head>

<body>
    <script src="js/three.min.js"></script>
    <script src="js/OrbitControls.js"></script>

    <script>
        const fov = 75;
        const nearClip = 0.1;
        const farClip = 1000;
        const terrainWidth =90;
        const terrainDepth = 30;
        const terrainMaxHeight = 2;

        var width = window.innerWidth;
        var height = window.innerHeight;
        var scene = new THREE.Scene();

        var camera = new THREE.PerspectiveCamera(fov, width / height, nearClip, farClip)
        camera.position.x = terrainWidth/2;
        camera.position.y = 7;
        camera.position.z = terrainDepth*0.9;

        //Add renderer to DOM
        var renderer = new THREE.WebGLRenderer();
        renderer.setSize(width, height);
        document.body.appendChild(renderer.domElement);


        window.addEventListener("resize", function () {
            width = window.innerWidth;
            height = window.innerHeight;
            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        });

        var controls = new THREE.OrbitControls(camera, renderer.domElement);
        camera.lookAt(new THREE.Vector3(terrainWidth/2, 0, 0));
        controls.target = new THREE.Vector3(terrainWidth/2, 0, 0);
        camera.updateProjectionMatrix();

        //initialise 2D array
        var randomArray = new Array(terrainWidth+1);
        for(let x = 0; x < terrainWidth+1; x++){
            randomArray[x] = new Array(terrainDepth+1);
        }

        //input random nums
        for (let z = 0; z < terrainDepth+1; z++) {
            for (let x = 0; x < terrainWidth+1; x++) {
                randomArray[x][z]=Math.random()*terrainMaxHeight;
            }
        }

        var geometry = new THREE.Geometry();

        for (let z = 0; z < terrainDepth; z++) {
            for (let x = 0; x < terrainWidth; x++) {
                geometry.vertices.push(
                    new THREE.Vector3(x, randomArray[x][z], z),
                    new THREE.Vector3(x + 1, randomArray[x+1][z], z),
                    new THREE.Vector3(x, randomArray[x][z+1], z+1),
                    new THREE.Vector3(x+1, randomArray[x+1][z+1], z+1),
                );

                let planeIndex = z*terrainWidth*4 + x*4;
                geometry.faces.push(
                    new THREE.Face3(planeIndex, planeIndex+1, planeIndex+2),
                    new THREE.Face3(planeIndex+1, planeIndex+2, planeIndex+3),
                );
            }
        }

        var material = new THREE.MeshBasicMaterial({ color: 0xFFFFFF, wireframe: true });

        var plane = new THREE.Mesh(geometry, material);
        scene.add(plane);


        //game logic
        function update() {
        }

        //render scenee
        function render() {
            renderer.render(scene, camera);
        }

        //run game loop ie update render
        function gameLoop() {
            requestAnimationFrame(gameLoop);
            update();
            render();
        }

        gameLoop();
    </script>
</body>

</html>