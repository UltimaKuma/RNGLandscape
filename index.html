<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>PerlinNoiseThreeJS</title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            width: 100%;
            height: 100%;
        }

        html {
            overflow: hidden;
        }
    </style>
</head>

<body>
    <script src="js/three/three.min.js"></script>
    <script src="js/three/GLTFLoader.js"></script>
    <script src="js/three/OrbitControls.js"></script>
    <script src="js/three/perlin.js"></script>

    <script src="js/three/EffectComposer.js"></script>
    <script src="js/three/CopyShader.js"></script>
    <script src="js/three/ShaderPass.js"></script>
    <script src="js/three/RenderPass.js"></script>

    <script src="js/three/GlitchPass.js"></script>
    <script src="js/three/DigitalGlitch.js"></script>

    <script>

        var scene;
        var renderer;
        var camera;
        var composer;
        var terrainModel;
        var sunModel;

        var glitchPass;
        var glitchEnabled = true;
        var glitchBassThreshold = 0.1;

        var audioBassResponse = 0;
        var currentAudioArray = [];

        var optionalUpdateQueue = [];

        // Affects display
        const fov = 75;
        const dispFog = true;
        // TODO - remove
        const orbitControls = false;
        var fps = 60;

        // Window init size
        var width = window.innerWidth;
        var height = window.innerHeight;

        class TerrainRandomiser {
            constructor(terrainWidth, terrainDepth, minHeight) {
                this.width = terrainWidth;
                this.depth = terrainDepth;
                this.minHeight = minHeight;
                // Affects height of various terrain
                this.microTerrainMaxHeight = 1;
                this.subTerrainMaxHeight = 4;
                this.superTerrainMaxHeight = 6;
                // Affects roughness of terrain
                this.microTerrainDivisor = 5;
                this.noiseStepScale = 20;
                this.noiseOffsetIncrement = 1 / this.noiseStepScale;
                this.noiseOffset = 0;
                // Initialise 2D array for random values
                this.terrainArray = new Array(this.depth + 1);
                for (let z = 0; z < this.depth + 1; z++) {
                    this.terrainArray[z] = new Array(this.width + 1);
                }

                // Seed simplex noise
                noise.seed(Math.random());

                // Generates terrain
                // Terrain composed of micro, sub and superterrain
                // Microterrain and subterrain consists of simplex noise
                // Superterrain consists of sine/cosine function to create a valley
                for (let z = 0; z < this.depth + 1; z++) {
                    for (let x = 0; x < this.width + 1; x++) {
                        let microTerrain = noise.simplex2((x + 100) / (this.noiseStepScale / this.microTerrainDivisor), (z + 100) / (this.noiseStepScale / this.microTerrainDivisor) + this.noiseOffset * this.microTerrainDivisor) * this.microTerrainMaxHeight;
                        let subTerrain = noise.simplex2(x / this.noiseStepScale, z / this.noiseStepScale + this.noiseOffset) * this.subTerrainMaxHeight;
                        let superTerrain = Math.cos(2 * Math.PI * x / this.width) * this.superTerrainMaxHeight;
                        this.terrainArray[z][x] = microTerrain + subTerrain + superTerrain;
                        this.terrainArray[z][x] = (this.terrainArray[z][x] <= this.minHeight) ? this.minHeight : this.terrainArray[z][x];
                    }
                }
                // Next call will be offset to simulate movement
                this.noiseOffset -= this.noiseOffsetIncrement;
            }

            stepTerrainHeight() {
                let z = 0;
                let nextTerrainArray = new Array();
                this.terrainArray.pop();
                for (let x = 0; x < this.width + 1; x++) {
                    let microTerrain = noise.simplex2((x + 100) / (this.noiseStepScale / this.microTerrainDivisor), (z + 100) / (this.noiseStepScale / this.microTerrainDivisor) + this.noiseOffset * this.microTerrainDivisor) * this.microTerrainMaxHeight;
                    let subTerrain = noise.simplex2(x / this.noiseStepScale, z / this.noiseStepScale + this.noiseOffset) * this.subTerrainMaxHeight;
                    let superTerrain = Math.cos(2 * Math.PI * x / this.width) * this.superTerrainMaxHeight;
                    nextTerrainArray[x] = microTerrain + subTerrain + superTerrain;
                    nextTerrainArray[x] = (nextTerrainArray[x] <= this.minHeight) ? this.minHeight : nextTerrainArray[x];
                }
                this.terrainArray.unshift(nextTerrainArray);
                this.noiseOffset -= this.noiseOffsetIncrement;
            }
        }

        class Terrain {
            constructor() {
                // Affects terrain
                this.terrainWidth = 80;
                this.terrainDepth = 100;
                this.terrainStep = 0.6;
                // Affects limits at which terrain is colored
                this.snowLimit = 5;
                this.mountainLimit = 0;
                this.grassLimit = -6;
                this.sandLimit = -7;
                // Terrain colors
                this.snowColor = 0xFFFFFF;
                this.mountainColor = 0x292f42;
                this.grassColor = 0x9bb2e0;
                this.sandColor = 0x37393d;
                this.waterColor = 0x6d98e8;
                // Generating random terrain heights
                this.terrainRandomiser = new TerrainRandomiser(this.terrainWidth, this.terrainDepth, this.sandLimit);

                // Generate terrain geometry
                this.geometry = new THREE.Geometry();
                for (let z = 0; z < this.terrainDepth; z++) {
                    for (let x = 0; x < this.terrainWidth; x++) {
                        // Creating a plane with vertices in order:
                        // 0-1
                        // |/|
                        // 2-3
                        this.geometry.vertices.push(
                            new THREE.Vector3(x, this.terrainRandomiser.terrainArray[z][x], z),
                            new THREE.Vector3(x + 1, this.terrainRandomiser.terrainArray[z][x + 1], z),
                            new THREE.Vector3(x, this.terrainRandomiser.terrainArray[z + 1][x], z + 1),
                            new THREE.Vector3(x + 1, this.terrainRandomiser.terrainArray[z + 1][x + 1], z + 1),
                        );

                        // Getting index for 0th vertex 
                        let planeIndex = z * this.terrainWidth * 4 + x * 4;
                        // Generating faces using vertices 0, 1, 2 and 1, 2, 3
                        this.geometry.faces.push(
                            new THREE.Face3(planeIndex, planeIndex + 2, planeIndex + 1),
                            new THREE.Face3(planeIndex + 1, planeIndex + 2, planeIndex + 3),
                        );
                    }
                }

                // Genrating mesh
                this.terrainMaterial = new THREE.MeshBasicMaterial({
                    color: 0xFFFFFF,
                    side: THREE.FrontSide,
                    vertexColors: THREE.FaceColors,
                });
                this.mesh = new THREE.Mesh(this.geometry, this.terrainMaterial);
                scene.add(this.mesh);

                // Generating inverse
                this.inverseTerrainMaterial = new THREE.MeshBasicMaterial({
                    color: 0x000000,
                    side: THREE.BackSide,
                    fog: false,
                    wireframe: false,
                });
                this.inverseTerrainMesh = new THREE.Mesh(this.geometry, this.inverseTerrainMaterial);
                this.inverseTerrainMesh.position.setY(this.inverseTerrainMesh.position.y + 0.1);
                this.mesh.add(this.inverseTerrainMesh);
            }

            updateTerrain() {
                this.mesh.position.z += this.terrainStep;
                if (this.mesh.position.z >= 1) {
                    //reset etep and render next chunk
                    this.mesh.position.z = 0;
                    this.terrainRandomiser.stepTerrainHeight();
                    for (let z = 0; z < this.terrainDepth; z++) {
                        for (let x = 0; x < this.terrainWidth; x++) {
                            let planeIndex = z * this.terrainWidth * 4 + x * 4;
                            this.geometry.vertices[planeIndex].y = this.terrainRandomiser.terrainArray[z][x];
                            this.geometry.vertices[planeIndex + 1].y = this.terrainRandomiser.terrainArray[z][x + 1];
                            this.geometry.vertices[planeIndex + 2].y = this.terrainRandomiser.terrainArray[z + 1][x];
                            this.geometry.vertices[planeIndex + 3].y = this.terrainRandomiser.terrainArray[z + 1][x + 1];
                        }
                    }
                    this.updateTerrainColor();
                    this.geometry.verticesNeedUpdate = true;
                }
            }

            // Colors faces of a plane depending on the y values of vertices
            updateTerrainColor() {
                this.geometry.faces.forEach(function (face) {
                    let maxY = Math.max(this.geometry.vertices[face.a].y, this.geometry.vertices[face.b].y, this.geometry.vertices[face.c].y);
                    let minY = Math.min(this.geometry.vertices[face.a].y, this.geometry.vertices[face.b].y, this.geometry.vertices[face.c].y);
                    if (maxY > this.snowLimit) {
                        face.color.setHex(this.snowColor);
                    } else if (maxY > this.mountainLimit) {
                        face.color.setHex(this.mountainColor);
                    } else if (maxY > this.grassLimit) {
                        face.color.setHex(this.grassColor);
                    } else if (maxY > this.sandLimit) {
                        face.color.setHex(this.sandColor);
                    } else {
                        face.color.setHex(this.waterColor);
                    }
                }.bind(this));
                this.geometry.colorsNeedUpdate = true;
            }
        }

        class Sun {
            constructor() {
                this.sunColor = 0xff2025;
                // Affects properties of sun
                this.maxSunScale = 5;
                // Add sun to scene
                this.sunGeometry = new THREE.SphereGeometry(24, 32, 32);
                this.sunAlpha = new THREE.TextureLoader().load("textures/sunAlpha.png");
                this.sunAlpha.minFilter = THREE.NearestFilter;
                this.sunMaterial = new THREE.MeshToonMaterial({
                    color: this.sunColor,
                    alphaMap: this.sunAlpha,
                    transparent: true,
                    wireframe: false,
                    fog: false,
                    shininess: 0,
                });
                this.sunMesh = new THREE.Mesh(this.sunGeometry, this.sunMaterial);
                this.sunMesh.position.set(40, 12, -12)
                scene.add(this.sunMesh);

                // Generating sun inverse
                this.inverseSunMaterial = new THREE.MeshBasicMaterial({
                    color: 0x000000,
                    alphaMap: this.sunAlpha,
                    transparent: true,
                    side: THREE.BackSide,
                    wireframe: false,
                    fog: false,
                });
                this.inverseSunMesh = new THREE.Mesh(this.sunGeometry, this.inverseSunMaterial);
                this.inverseSunMesh.scale.set(1.01, 1.01, 1.01);
                this.sunMesh.add(this.inverseSunMesh);

                // Audio
                this.audioResponse = 0;
            }

            setAudio(audioArray) {
                if (audioArray === undefined) return;
                let total = 0;
                // Average whole audio response
                for (let i = 0; i < audioArray.length; i++) {
                    total += audioArray[i];
                }
                this.audioResponse = total / audioArray.length;
            }

            update() {
                let scaleDiff = sunModel.maxSunScale - 1;
                let sunScale = (scaleDiff * this.audioResponse) + 1;
                this.sunMesh.scale.set(sunScale, sunScale, sunScale);
            }
        }

        class BDD {
            constructor() {
                this.bddScene;
                this.orbitRadius = 36;
                // BDD rotation
                this.xRotationOffset = Math.PI / 2;
                this.yRotationOffset = Math.PI;
                this.zRotationOffset = Math.PI / 2;
                // BDD position (is relative to sun)
                this.xPos = sunModel.sunMesh.position.x;
                this.yPos = sunModel.sunMesh.position.y;
                this.zPos = sunModel.sunMesh.position.z;
                // Audio
                this.audioResponse = 0
                // Trail audio max
                this.maxTrailScale = 5;
                // Instantiate a loader
                let loader = new THREE.GLTFLoader();

                // Load a glTF resource
                loader.load(
                    // resource URL
                    'models/toonBDD.glb',

                    // called when the resource is loaded
                    function (gltf) {
                        console.log(gltf.scene);
                        this.bddScene = gltf.scene;
                        scene.add(gltf.scene);

                        this.bddScene.traverse((o) => {
                            if (o.isMesh) {
                                o.material = this.toToonMaterial(o.material)
                            };
                            if (o.parent.name == "bddInverse") o.material.side = THREE.FrontSide;
                        });

                        optionalUpdateQueue.push(this);
                    }.bind(this),

                    // called while loading is progressing
                    function (xhr) {
                        console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                    },

                    // called when loading has errors
                    function (error) {
                        console.log(error);
                    }
                );

                this.trailGeometry = new THREE.Geometry();
                // this.trailGeometry.vertices = new Array(100);
                for (let i = 0; i < 100; i++) {
                    this.trailGeometry.vertices.unshift(new THREE.Vector3(this.xPos, this.yPos, this.zPos));
                }

                this.trailLine = new THREE.Line(this.trailGeometry, new THREE.LineBasicMaterial({
                    color: 0xffffff,
                }));
                scene.add(this.trailLine);
            }

            toToonMaterial(material) {
                let toonMaterial = new THREE.MeshToonMaterial({
                    color: material.color,
                    fog: false,
                    wireframe: false,
                    shininess: 0,
                    // TURNS OUT ALL MODEL MESHES WERE BACKWARDS (Aside from mouth)
                    side: THREE.BackSide
                });
                return toonMaterial;
            }

            setAudio(audioArray) {
                if (audioArray === undefined) console.log(audioArray);
                let total = 0;
                // Average whole audio response
                for (let i = 0; i < audioArray.length; i++) {
                    total += audioArray[i];
                }
                this.audioResponse = total / audioArray.length;
            }

            update() {
                // Function for orbit around "sun"
                let timer = Date.now() * 0.00025;
                this.xPos = Math.sin(timer * 7) * this.orbitRadius * ((this.maxTrailScale - 1) * this.audioResponse + 1) + sunModel.sunMesh.position.x;
                this.yPos = Math.cos(timer * 5) * this.orbitRadius * ((this.maxTrailScale - 1) * this.audioResponse + 1) + sunModel.sunMesh.position.y;
                this.zPos = Math.cos(timer * 3) * this.orbitRadius * ((this.maxTrailScale - 1) * this.audioResponse + 1) + sunModel.sunMesh.position.z;
                this.bddScene.position.set(this.xPos, this.yPos, this.zPos)

                // Update trail following bdd
                this.trailGeometry.vertices.unshift(new THREE.Vector3(this.xPos, this.yPos, this.zPos));
                if (this.trailGeometry.vertices.length > 100) {
                    this.trailGeometry.vertices.pop();
                }
                this.trailGeometry.verticesNeedUpdate = true;

                // Rotate around center
                this.bddScene.rotation.set(timer * 7 + this.xRotationOffset, timer * 5 + this.yRotationOffset, timer * 3 + this.zRotationOffset);
            }

            remove() {
                scene.remove(this.bddScene);
                scene.remove(this.trailLine);
            }
        }

        // Converts from rgb string to hex number value
        function rgbToHex(rgb) {
            let rgbArray = rgb.split(" ");
            let r = Math.floor(parseFloat(rgbArray[0]) * 255);
            let g = Math.floor(parseFloat(rgbArray[1]) * 255);
            let b = Math.floor(parseFloat(rgbArray[2]) * 255);
            let hex = r * 256 * 256 + g * 256 + b;
            return hex;
        }

        // Game logic
        function update() {
            terrainModel.updateTerrain();
            // TODO - Update audio response
            sunModel.setAudio(currentAudioArray);
            sunModel.update();
            // Optional objects updated
            optionalUpdateQueue.forEach(function (model) {
                model.setAudio(currentAudioArray);
                model.update();
            });
            // Update shader depending on response
            let total = 0;
            for (let i = 0; i < 9; i++) {
                // Left ear
                total += currentAudioArray[i];
                // Right ear
                total += currentAudioArray[i + 64];
            }
            let audioBassResponse = total / 18;
            // TODO - remove
            audioBassResponse = Math.max(...currentAudioArray);

            if (glitchEnabled) {
                // Check if above glitchBassThreshold
                if (audioBassResponse >= glitchBassThreshold) {
                    glitchPass.enabled = true;
                } else {
                    glitchPass.enabled = false;
                }
            } else {
                glitchPass.enabled = false;
            }
        }

        // Render scene
        function render() {
            renderer.render(scene, camera);
        }

        // Run game loop ie update, render
        function gameLoop() {
            setTimeout(function () {
                requestAnimationFrame(gameLoop);
            }, 1000 / fps);
            update();
            // Render using the passes set up
            composer.render();
        }

        function init() {
            scene = new THREE.Scene();

            // Initialising mandatory components of scene
            terrainModel = new Terrain();
            sunModel = new Sun();

            // Adding fog to scene
            if (dispFog) {
                scene.fog = new THREE.Fog(new THREE.Color(0xaed4fa), 0.0025, 100);
            }

            // Add lighting
            var light = new THREE.DirectionalLight(0xffffff);
            light.position.set(1, 1, 6);
            scene.add(light);
            scene.add(new THREE.AmbientLight(0x404040));

            // Loading texture for background
            scene.background = new THREE.TextureLoader().load("textures/backgroundTexture.png")

            // Positioning camera
            camera = new THREE.PerspectiveCamera(fov, width / height, 1, 1000)
            camera.position.x = terrainModel.terrainWidth / 2;
            camera.position.y = 3;
            camera.position.z = terrainModel.terrainDepth * 1;

            // Adding renderer to DOM
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(width, height);
            document.body.appendChild(renderer.domElement);

            // Post
            composer = new THREE.EffectComposer(renderer);
            composer.addPass(new THREE.RenderPass(scene, camera));
            glitchPass = new THREE.GlitchPass(0);
            composer.addPass(glitchPass);

            // Handler to resize window
            window.addEventListener("resize", function () {
                width = window.innerWidth;
                height = window.innerHeight;
                renderer.setSize(width, height);
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
            });

            // Orbit controls
            if (orbitControls) {
                var controls = new THREE.OrbitControls(camera, renderer.domElement);
                camera.lookAt(new THREE.Vector3(terrainModel.terrainWidth / 2, 0, 0));
                controls.target = new THREE.Vector3(terrainModel.terrainWidth / 2, 0, 0);
                camera.updateProjectionMatrix();
            }

            // WallpaperEngine properties handler
            window.wallpaperPropertyListener = {
                // General Properties ie fps slider in settings etc
                applyGeneralProperties: function (properties) {
                    if (properties.fps) {
                        fps = properties.fps;
                    }
                },

                // User Properties
                applyUserProperties: function (properties) {
                    if (properties.fogColor) {
                        let fogColor = rgbToHex(properties.fogColor.value);
                        scene.fog = new THREE.Fog(new THREE.Color(fogColor), 0.0025, 100);
                    }
                    if (properties.snowColor) {
                        terrainModel.snowColor = rgbToHex(properties.snowColor.value);
                    }
                    if (properties.mountainColor) {
                        terrainModel.mountainColor = rgbToHex(properties.mountainColor.value);
                    }
                    if (properties.grassColor) {
                        terrainModel.grassColor = rgbToHex(properties.grassColor.value);
                    }
                    if (properties.sandColor) {
                        terrainModel.sandColor = rgbToHex(properties.sandColor.value);
                    }
                    if (properties.waterColor) {
                        terrainModel.waterColor = rgbToHex(properties.waterColor.value);
                    }
                    if (properties.sunColor) {
                        sunModel.sunColor = rgbToHex(properties.sunColor.value);
                        sunModel.sunMesh.material.color.setHex(sunModel.sunColor);
                    }
                    if (properties.velocity) {
                        terrainModel.terrainStep = properties.velocity.value / 10;
                    }
                    if (properties.backgroundImage) {
                        let imagePath;
                        if (properties.backgroundImage.value) {
                            // Create a valid location path
                            imagePath = "file:///" + properties.backgroundImage.value;
                        } else {
                            // Reset image when null
                            imagePath = "textures/backgroundTexture.png";
                        }
                        scene.background = new THREE.TextureLoader().load(imagePath);
                    }
                    if (properties.sunResponsiveness) {
                        sunModel.maxSunScale = properties.sunResponsiveness.value;
                    }
                    if (properties.bdd) {
                        // If index is -1, does not exist
                        let index = optionalUpdateQueue.findIndex(function (model) {
                            return model instanceof BDD;
                        });
                        if (properties.bdd.value && index === -1) {
                            // If bdd on but doesnt exist
                            // Call constructor, which will add itself to update queue
                            new BDD();
                        } else if (!properties.bdd.value && index !== -1) {
                            // If bdd off but does exist
                            // Remove model from scene
                            optionalUpdateQueue[index].remove();
                            optionalUpdateQueue.splice(index);
                        }
                    }
                    if (properties.bddResponsiveness) {
                        // If index is -1, does not exist
                        let index = optionalUpdateQueue.findIndex(function (model) {
                            return model instanceof BDD;
                        });
                        if (index !== -1) {
                            // If BDD exists, update value
                            // TODO - might be a problem if BDD removed and added
                            optionalUpdateQueue[index].maxTrailScale = properties.bddResponsiveness.value;
                        }
                    }
                    if (properties.glitchBassEffect) {
                        glitchEnabled = properties.glitchBassEffect.value;
                    }
                    if (properties.glitchBassThreshold) {
                        glitchBassThreshold = properties.glitchBassThreshold.value / 100;
                    }
                }
            };


            // Adding audio handler as listener
            window.onload = function () {
                window.wallpaperRegisterAudioListener(function (audioArray) {
                    currentAudioArray = audioArray;
                });
            };

            gameLoop();
        }

        init();


    </script>
</body>

</html>