<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>PerlinNoiseThreeJS</title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            width: 100%;
            height: 100%;
        }

        html {
            overflow: hidden;
        }
    </style>
</head>

<body>
    <script src="js/three.min.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/perlin.js"></script>

    <script>
        const fps = 15;
        const fov = 75;
        const nearClip = 0.1;
        const farClip = 1000;
        const terrainWidth = 80;
        const terrainDepth = 30;

        // Affects height of various terrain
        const microTerrainMaxHeight = 1;
        const subTerrainMaxHeight = 4;
        const superTerrainMaxHeight = 6;

        // Affects roughness of microterrain
        const microTerrainDivisor = 8;

        const noiseStepScale = 15;
        var noiseOffsetIncrement = 0.2;
        var noiseOffset = 0;

        var width = window.innerWidth;
        var height = window.innerHeight;

        var scene = new THREE.Scene();

        // Adding fog to scene
        fogColor = new THREE.Color(0x000000);
        scene.background = fogColor;
        scene.fog = new THREE.Fog(fogColor, 0.0025, 40);

        var camera = new THREE.PerspectiveCamera(fov, width / height, nearClip, farClip)
        camera.position.x = terrainWidth / 2;
        camera.position.y = 3;
        camera.position.z = terrainDepth * 1.1;

        //Add renderer to DOM
        var renderer = new THREE.WebGLRenderer();
        renderer.setSize(width, height);
        document.body.appendChild(renderer.domElement);


        window.addEventListener("resize", function () {
            width = window.innerWidth;
            height = window.innerHeight;
            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        });

        var controls = new THREE.OrbitControls(camera, renderer.domElement);
        camera.lookAt(new THREE.Vector3(terrainWidth / 2, 0, 0));
        controls.target = new THREE.Vector3(terrainWidth / 2, 0, 0);
        camera.updateProjectionMatrix();

        //initialise 2D array
        var randomArray = new Array(terrainWidth + 1);
        for (let x = 0; x < terrainWidth + 1; x++) {
            randomArray[x] = new Array(terrainDepth + 1);
        }

        // Seed simplex noise
        noise.seed(Math.random());

        // Generate terrain
        // Terrain composed of sub and superterrain
        // Subterrain consists of simplex noise
        // Superterrain consists of sine/cosine function to create a valley
        for (let z = 0; z < terrainDepth + 1; z++) {
            for (let x = 0; x < terrainWidth + 1; x++) {
                let microTerrain = noise.simplex2((x+100) / noiseStepScale, (z+100) / noiseStepScale) * microTerrainMaxHeight;
                let subTerrain = noise.simplex2(x / noiseStepScale, z / noiseStepScale) * subTerrainMaxHeight;
                let superTerrain = Math.cos(2 * Math.PI * x / terrainWidth) * superTerrainMaxHeight;
                randomArray[x][z] = subTerrain + superTerrain + microTerrain;
            }
        }

        var geometry = new THREE.Geometry();

        for (let z = 0; z < terrainDepth; z++) {
            for (let x = 0; x < terrainWidth; x++) {
                // Creating a plane with vertices in order:
                // 0-1
                // |/|
                // 2-3
                geometry.vertices.push(
                    new THREE.Vector3(x, randomArray[x][z], z),
                    new THREE.Vector3(x + 1, randomArray[x + 1][z], z),
                    new THREE.Vector3(x, randomArray[x][z + 1], z + 1),
                    new THREE.Vector3(x + 1, randomArray[x + 1][z + 1], z + 1),
                );

                // Getting index for 0th vertex 
                let planeIndex = z * terrainWidth * 4 + x * 4;
                // Generating faces using vertices 0, 1, 2 and 1, 2, 3
                geometry.faces.push(
                    new THREE.Face3(planeIndex, planeIndex + 1, planeIndex + 2),
                    new THREE.Face3(planeIndex + 1, planeIndex + 2, planeIndex + 3),
                );
            }
        }

        // Genrating mesh
        var meshMaterial = new THREE.MeshBasicMaterial({
            color: 0x000000,
            side: THREE.DoubleSide,
            polygonOffset: true,
            polygonOffsetFactor: 1,
            polygonOffsetUnits: 1,
        });
        var mesh = new THREE.Mesh(geometry, meshMaterial);
        scene.add(mesh);

        // Generating wireframe
        var wireframeMaterial = new THREE.MeshBasicMaterial({
            color: 0xFFFFFF,
            wireframe: true,
        });
        var wireframe = new THREE.LineSegments(mesh.geometry, wireframeMaterial);
        mesh.add(wireframe);

        //game logic
        function update() {
            for (let z = 0; z < terrainDepth + 1; z++) {
                for (let x = 0; x < terrainWidth + 1; x++) {
                    let microTerrain = noise.simplex2((x+100) / (noiseStepScale/microTerrainDivisor), (z+100) / (noiseStepScale/microTerrainDivisor)+noiseOffset*microTerrainDivisor) * microTerrainMaxHeight;
                    let subTerrain = noise.simplex2(x / noiseStepScale, z / noiseStepScale + noiseOffset) * subTerrainMaxHeight;
                    let superTerrain = Math.cos(2 * Math.PI * x / terrainWidth) * superTerrainMaxHeight;
                    randomArray[x][z] = microTerrain + subTerrain + superTerrain;
                }
            }

            for (let z = 0; z < terrainDepth; z++) {
                for (let x = 0; x < terrainWidth; x++) {
                    let planeIndex = z * terrainWidth * 4 + x * 4;
                    geometry.vertices[planeIndex].y = randomArray[x][z];
                    geometry.vertices[planeIndex + 1].y = randomArray[x + 1][z];
                    geometry.vertices[planeIndex + 2].y = randomArray[x][z + 1];
                    geometry.vertices[planeIndex + 3].y = randomArray[x + 1][z + 1];
                }
            }
            geometry.verticesNeedUpdate = true;
            noiseOffset -= noiseOffsetIncrement;
        }

        //render scenee
        function render() {
            renderer.render(scene, camera);
        }

        //run game loop ie update render
        function gameLoop() {
            setTimeout(function () {
                requestAnimationFrame(gameLoop);
            }, 1000 / fps);
            update();
            render();
        }

        gameLoop();
    </script>
</body>

</html>